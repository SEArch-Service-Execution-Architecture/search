package main

import (
	"context"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"time"

	"github.com/google/uuid"

	pb "dc.uba.ar/this/search/protobuf"
	"google.golang.org/grpc"

	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/testdata"
)

var (
	tls      	= flag.Bool("tls", false, "Connection uses TLS if true, else plain TCP")
	certFile 	= flag.String("cert_file", "", "The TLS cert file")
	keyFile  	= flag.String("key_file", "", "The TLS key file")
	caFile      = flag.String("ca_file", "", "The file containing the CA root cert file")
	port     	= flag.Int("port", 10000, "The server port")
	brokerAddr  = flag.String("broker_addr", "localhost", "The server address in the format of host:port")
	brokerPort  = flag.Int("broker_port", 10000, "The port in which the broker is listening")
)

type middlewareServer struct {
	pb.UnimplementedPublicMiddlewareServer
	pb.UnimplementedPrivateMiddlewareServer

	registeredApps map[string]pb.PrivateMiddleware_RegisterAppServer
	registeredChannels map[string]registeredChannel
}

type registeredChannel struct {
	Contract pb.Contract
	Others map[string]pb.RemoteParticipant
}

func NewRegisteredChannel() *registeredChannel {
	var r registeredChannel
	r.Others = make(map[string]pb.RemoteParticipant)
	return &r
}

func (s *middlewareServer) RegisterApp(req *pb.RegisterAppRequest, stream pb.PrivateMiddleware_RegisterAppServer) error {
	// TODO: talk to the Registry to get my app_id
	mockUUID, _ := uuid.NewRandom() // TODO: this should be generated by the Registry
	ack := pb.RegisterAppResponse{
		AckOrNew: &pb.RegisterAppResponse_AppId{
			AppId: mockUUID.String()}}
	if err := stream.Send(&ack); err != nil {
		return err
	}
	s.registeredApps[mockUUID.String()] = stream
	return nil
}

func (s *middlewareServer) connectBroker() pb.BrokerClient {
	var opts []grpc.DialOption
	if *tls {
		if *caFile == "" {
			*caFile = testdata.Path("ca.pem")
		}
		// creds, err := credentials.NewClientTLSFromFile(*caFile, *serverHostOverride)
		// if err != nil {
		// 	log.Fatalf("Failed to create TLS credentials %v", err)
		//}
		//opts = append(opts, grpc.WithTransportCredentials(creds))
	} else {
		opts = append(opts, grpc.WithInsecure())
	}
	opts = append(opts, grpc.WithBlock())

	// fmt.Println("Waiting 2 seconds for broker...")
	// time.Sleep(2 * time.Second)

	conn, err := grpc.Dial(fmt.Sprintf("%s:%d", *brokerAddr, *brokerPort), opts...)
	if err != nil {
		log.Fatalf("fail to dial: %v", err)
	}
	// defer conn.Close()
	return pb.NewBrokerClient(conn)
	// TODO: we have to close connection eventually...
}



func (s *middlewareServer) RegisterChannel(ctx context.Context, in *pb.RegisterChannelRequest) (*pb.RegisterChannelResponse, error) {
	client := s.connectBroker()
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	brokerresult, err := client.BrokerChannel(ctx, &pb.BrokerChannelRequest{Contract: in.GetRequirementsContract() })
	if err != nil {
		log.Fatalf("%v.BrokerChannel(_) = _, %v: ", client, err)
	}

	channelInfo := NewRegisteredChannel()
	channelInfo.Contract = *in.GetRequirementsContract()
	for localname,v := range brokerresult.GetParticipants() {
		channelInfo.Others[localname] = *v
	}
	s.registeredChannels[brokerresult.GetChannelId()] = *channelInfo
	
	return &pb.RegisterChannelResponse{ChannelId: brokerresult.GetChannelId()}, nil 
}

// When the middleware receives a message in its public interface, it must enqueue it so that
// the corresponding local app can receive it
func (s *middlewareServer) MessageExchange(stream pb.PublicMiddleware_MessageExchangeServer) error {
	for {
		in, err := stream.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}

		fmt.Println("Received message from", in.SenderId, ":", string(in.Content.Body))

		// TODO: send to local app replacing sender name with local name

		ack := pb.ApplicationMessageWithHeaders{
			ChannelId:   in.ChannelId,
			RecipientId: in.SenderId,
			SenderId:    "provmwID-44",
			Content:     &pb.MessageContent{Body: []byte("ack")}}

		if err := stream.Send(&ack); err != nil {
			return err
		}
	}
}

func main() {
	flag.Parse()
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	var opts []grpc.ServerOption
	if *tls {
		if *certFile == "" {
			*certFile = testdata.Path("server1.pem")
		}
		if *keyFile == "" {
			*keyFile = testdata.Path("server1.key")
		}
		creds, err := credentials.NewServerTLSFromFile(*certFile, *keyFile)
		if err != nil {
			log.Fatalf("Failed to generate credentials %v", err)
		}
		opts = []grpc.ServerOption{grpc.Creds(creds)}
	}
	grpcServer := grpc.NewServer(opts...)

	var pms middlewareServer
	pb.RegisterPublicMiddlewareServer(grpcServer, &pms)
	grpcServer.Serve(lis)
}
